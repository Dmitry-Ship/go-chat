// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deactivateConversation = `-- name: DeactivateConversation :exec
UPDATE conversations
SET is_active = FALSE, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeactivateConversation(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deactivateConversation, id)
	return err
}

const deactivateParticipant = `-- name: DeactivateParticipant :exec
UPDATE participants
SET is_active = FALSE, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeactivateParticipant(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deactivateParticipant, id)
	return err
}

const findParticipantByConversationAndUser = `-- name: FindParticipantByConversationAndUser :one
SELECT id, conversation_id, user_id, is_active, created_at, updated_at, deleted_at FROM participants
WHERE conversation_id = $1 AND user_id = $2 AND deleted_at IS NULL
LIMIT 1
`

type FindParticipantByConversationAndUserParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	UserID         pgtype.UUID `json:"user_id"`
}

func (q *Queries) FindParticipantByConversationAndUser(ctx context.Context, arg FindParticipantByConversationAndUserParams) (Participant, error) {
	row := q.db.QueryRow(ctx, findParticipantByConversationAndUser, arg.ConversationID, arg.UserID)
	var i Participant
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.UserID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const findUserByUsername = `-- name: FindUserByUsername :one
SELECT id, avatar, name, password, refresh_token, created_at, updated_at, deleted_at FROM users
WHERE name = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) FindUserByUsername(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByUsername, name)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Avatar,
		&i.Name,
		&i.Password,
		&i.RefreshToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getContacts = `-- name: GetContacts :many

SELECT id, name, avatar
FROM users
WHERE deleted_at IS NULL AND id != $1
LIMIT $2 OFFSET $3
`

type GetContactsParams struct {
	ID     pgtype.UUID `json:"id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetContactsRow struct {
	ID     pgtype.UUID `json:"id"`
	Name   string      `json:"name"`
	Avatar pgtype.Text `json:"avatar"`
}

// Complex queries for read model
func (q *Queries) GetContacts(ctx context.Context, arg GetContactsParams) ([]GetContactsRow, error) {
	rows, err := q.db.Query(ctx, getContacts, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContactsRow
	for rows.Next() {
		var i GetContactsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Avatar); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationByID = `-- name: GetConversationByID :one
SELECT id, type, is_active, created_at, updated_at, deleted_at FROM conversations
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetConversationByID(ctx context.Context, id pgtype.UUID) (Conversation, error) {
	row := q.db.QueryRow(ctx, getConversationByID, id)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getConversationFull = `-- name: GetConversationFull :one
WITH participants_count AS (
    SELECT COUNT(*) as count
    FROM participants
    WHERE conversation_id = $1
      AND is_active = TRUE
      AND deleted_at IS NULL
)
SELECT
    c.id as conversation_id,
    c.created_at,
    c.type,
    ou.id as other_user_id,
    ou.name as other_user_name,
    ou.avatar as other_user_avatar,
    gc.avatar as group_avatar,
    gc.name as group_name,
    gc.owner_id as group_owner_id,
    pc.count as participants_count,
    up.id as user_participant_id
FROM conversations c
LEFT JOIN participants op ON op.conversation_id = c.id
    AND op.user_id <> $2
    AND op.is_active = TRUE
LEFT JOIN users ou ON ou.id = op.user_id
LEFT JOIN group_conversations gc ON gc.conversation_id = c.id
LEFT JOIN participants pc_sub ON pc_sub.conversation_id = c.id AND pc_sub.user_id = $2 AND pc_sub.is_active = TRUE
LEFT JOIN participants up ON up.conversation_id = c.id AND up.user_id = $2 AND up.is_active = TRUE
CROSS JOIN participants_count pc
WHERE c.id = $1 AND c.is_active = TRUE AND c.deleted_at IS NULL
LIMIT 1
`

type GetConversationFullParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetConversationFullRow struct {
	ConversationID    pgtype.UUID        `json:"conversation_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	Type              int32              `json:"type"`
	OtherUserID       pgtype.UUID        `json:"other_user_id"`
	OtherUserName     pgtype.Text        `json:"other_user_name"`
	OtherUserAvatar   pgtype.Text        `json:"other_user_avatar"`
	GroupAvatar       pgtype.Text        `json:"group_avatar"`
	GroupName         pgtype.Text        `json:"group_name"`
	GroupOwnerID      pgtype.UUID        `json:"group_owner_id"`
	ParticipantsCount int64              `json:"participants_count"`
	UserParticipantID pgtype.UUID        `json:"user_participant_id"`
}

func (q *Queries) GetConversationFull(ctx context.Context, arg GetConversationFullParams) (GetConversationFullRow, error) {
	row := q.db.QueryRow(ctx, getConversationFull, arg.ID, arg.UserID)
	var i GetConversationFullRow
	err := row.Scan(
		&i.ConversationID,
		&i.CreatedAt,
		&i.Type,
		&i.OtherUserID,
		&i.OtherUserName,
		&i.OtherUserAvatar,
		&i.GroupAvatar,
		&i.GroupName,
		&i.GroupOwnerID,
		&i.ParticipantsCount,
		&i.UserParticipantID,
	)
	return i, err
}

const getConversationMessagesWithUser = `-- name: GetConversationMessagesWithUser :many
SELECT
    m.id,
    m.type,
    m.created_at,
    m.conversation_id,
    m.content,
    u.id as user_id,
    u.name as user_name,
    u.avatar as user_avatar
FROM messages m
LEFT JOIN users u ON u.id = m.user_id
WHERE m.conversation_id = $1 AND m.deleted_at IS NULL
ORDER BY m.created_at ASC
LIMIT $2 OFFSET $3
`

type GetConversationMessagesWithUserParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type GetConversationMessagesWithUserRow struct {
	ID             pgtype.UUID        `json:"id"`
	Type           int32              `json:"type"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	ConversationID pgtype.UUID        `json:"conversation_id"`
	Content        string             `json:"content"`
	UserID         pgtype.UUID        `json:"user_id"`
	UserName       pgtype.Text        `json:"user_name"`
	UserAvatar     pgtype.Text        `json:"user_avatar"`
}

func (q *Queries) GetConversationMessagesWithUser(ctx context.Context, arg GetConversationMessagesWithUserParams) ([]GetConversationMessagesWithUserRow, error) {
	rows, err := q.db.Query(ctx, getConversationMessagesWithUser, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversationMessagesWithUserRow
	for rows.Next() {
		var i GetConversationMessagesWithUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.CreatedAt,
			&i.ConversationID,
			&i.Content,
			&i.UserID,
			&i.UserName,
			&i.UserAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDirectConversationBetweenUsers = `-- name: GetDirectConversationBetweenUsers :one
SELECT c.id, c.type, c.is_active, c.created_at, c.updated_at, c.deleted_at
FROM conversations c
JOIN participants p1 ON p1.conversation_id = c.id AND p1.user_id = $1 AND p1.is_active = TRUE
JOIN participants p2 ON p2.conversation_id = c.id AND p2.user_id = $2 AND p2.is_active = TRUE
WHERE c.type = 1
  AND c.is_active = TRUE
  AND c.deleted_at IS NULL
  AND p1.deleted_at IS NULL
  AND p2.deleted_at IS NULL
LIMIT 1
`

type GetDirectConversationBetweenUsersParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	UserID_2 pgtype.UUID `json:"user_id_2"`
}

func (q *Queries) GetDirectConversationBetweenUsers(ctx context.Context, arg GetDirectConversationBetweenUsersParams) (Conversation, error) {
	row := q.db.QueryRow(ctx, getDirectConversationBetweenUsers, arg.UserID, arg.UserID_2)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getGroupConversationByID = `-- name: GetGroupConversationByID :one
SELECT id, name, avatar, conversation_id, owner_id, created_at, updated_at, deleted_at FROM group_conversations
WHERE conversation_id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetGroupConversationByID(ctx context.Context, conversationID pgtype.UUID) (GroupConversation, error) {
	row := q.db.QueryRow(ctx, getGroupConversationByID, conversationID)
	var i GroupConversation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Avatar,
		&i.ConversationID,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getGroupConversationByOwnerID = `-- name: GetGroupConversationByOwnerID :many
SELECT gc.id, gc.name, gc.avatar, gc.conversation_id, gc.owner_id, gc.created_at, gc.updated_at, gc.deleted_at, c.id, c.type, c.is_active, c.created_at, c.updated_at, c.deleted_at
FROM group_conversations gc
JOIN conversations c ON c.id = gc.conversation_id
WHERE gc.owner_id = $1 AND gc.deleted_at IS NULL AND c.deleted_at IS NULL
`

type GetGroupConversationByOwnerIDRow struct {
	ID             pgtype.UUID        `json:"id"`
	Name           string             `json:"name"`
	Avatar         pgtype.Text        `json:"avatar"`
	ConversationID pgtype.UUID        `json:"conversation_id"`
	OwnerID        pgtype.UUID        `json:"owner_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	ID_2           pgtype.UUID        `json:"id_2"`
	Type           int32              `json:"type"`
	IsActive       bool               `json:"is_active"`
	CreatedAt_2    pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2    pgtype.Timestamptz `json:"updated_at_2"`
	DeletedAt_2    pgtype.Timestamptz `json:"deleted_at_2"`
}

func (q *Queries) GetGroupConversationByOwnerID(ctx context.Context, ownerID pgtype.UUID) ([]GetGroupConversationByOwnerIDRow, error) {
	rows, err := q.db.Query(ctx, getGroupConversationByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupConversationByOwnerIDRow
	for rows.Next() {
		var i GetGroupConversationByOwnerIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Avatar,
			&i.ConversationID,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.Type,
			&i.IsActive,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupConversationWithOwner = `-- name: GetGroupConversationWithOwner :one
SELECT
    gc.id,
    gc.name,
    gc.avatar,
    gc.conversation_id,
    gc.owner_id,
    c.type as conversation_type,
    c.is_active as conversation_is_active,
    p.id as owner_participant_id,
    p.user_id as owner_user_id,
    p.conversation_id as owner_conversation_id,
    p.is_active as owner_is_active
FROM group_conversations gc
JOIN conversations c ON c.id = gc.conversation_id
JOIN participants p ON p.conversation_id = gc.conversation_id AND p.user_id = gc.owner_id
WHERE gc.conversation_id = $1
  AND gc.deleted_at IS NULL
  AND c.deleted_at IS NULL
  AND p.deleted_at IS NULL
LIMIT 1
`

type GetGroupConversationWithOwnerRow struct {
	ID                   pgtype.UUID `json:"id"`
	Name                 string      `json:"name"`
	Avatar               pgtype.Text `json:"avatar"`
	ConversationID       pgtype.UUID `json:"conversation_id"`
	OwnerID              pgtype.UUID `json:"owner_id"`
	ConversationType     int32       `json:"conversation_type"`
	ConversationIsActive bool        `json:"conversation_is_active"`
	OwnerParticipantID   pgtype.UUID `json:"owner_participant_id"`
	OwnerUserID          pgtype.UUID `json:"owner_user_id"`
	OwnerConversationID  pgtype.UUID `json:"owner_conversation_id"`
	OwnerIsActive        bool        `json:"owner_is_active"`
}

func (q *Queries) GetGroupConversationWithOwner(ctx context.Context, conversationID pgtype.UUID) (GetGroupConversationWithOwnerRow, error) {
	row := q.db.QueryRow(ctx, getGroupConversationWithOwner, conversationID)
	var i GetGroupConversationWithOwnerRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Avatar,
		&i.ConversationID,
		&i.OwnerID,
		&i.ConversationType,
		&i.ConversationIsActive,
		&i.OwnerParticipantID,
		&i.OwnerUserID,
		&i.OwnerConversationID,
		&i.OwnerIsActive,
	)
	return i, err
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT m.id, m.conversation_id, m.user_id, m.content, m.type, m.created_at, m.updated_at, m.deleted_at, u.name as user_name, u.avatar as user_avatar
FROM messages m
JOIN users u ON u.id = m.user_id
WHERE m.id = $1 AND m.deleted_at IS NULL
LIMIT 1
`

type GetMessageByIDRow struct {
	ID             pgtype.UUID        `json:"id"`
	ConversationID pgtype.UUID        `json:"conversation_id"`
	UserID         pgtype.UUID        `json:"user_id"`
	Content        string             `json:"content"`
	Type           int32              `json:"type"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	UserName       string             `json:"user_name"`
	UserAvatar     pgtype.Text        `json:"user_avatar"`
}

func (q *Queries) GetMessageByID(ctx context.Context, id pgtype.UUID) (GetMessageByIDRow, error) {
	row := q.db.QueryRow(ctx, getMessageByID, id)
	var i GetMessageByIDRow
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.UserID,
		&i.Content,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserName,
		&i.UserAvatar,
	)
	return i, err
}

const getMessagesForConversation = `-- name: GetMessagesForConversation :many
SELECT m.id, m.conversation_id, m.user_id, m.content, m.type, m.created_at, m.updated_at, m.deleted_at, u.name as user_name, u.avatar as user_avatar
FROM messages m
JOIN users u ON u.id = m.user_id
WHERE m.conversation_id = $1 AND m.deleted_at IS NULL
ORDER BY m.created_at ASC
LIMIT $2 OFFSET $3
`

type GetMessagesForConversationParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type GetMessagesForConversationRow struct {
	ID             pgtype.UUID        `json:"id"`
	ConversationID pgtype.UUID        `json:"conversation_id"`
	UserID         pgtype.UUID        `json:"user_id"`
	Content        string             `json:"content"`
	Type           int32              `json:"type"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	UserName       string             `json:"user_name"`
	UserAvatar     pgtype.Text        `json:"user_avatar"`
}

func (q *Queries) GetMessagesForConversation(ctx context.Context, arg GetMessagesForConversationParams) ([]GetMessagesForConversationRow, error) {
	rows, err := q.db.Query(ctx, getMessagesForConversation, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessagesForConversationRow
	for rows.Next() {
		var i GetMessagesForConversationRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.UserID,
			&i.Content,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserName,
			&i.UserAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationMessageWithUser = `-- name: GetNotificationMessageWithUser :one
SELECT
    m.id,
    m.type,
    m.created_at,
    m.conversation_id,
    m.content,
    u.id as user_id,
    u.name as user_name,
    u.avatar as user_avatar
FROM messages m
LEFT JOIN users u ON u.id = m.user_id
WHERE m.id = $1 AND m.deleted_at IS NULL
LIMIT 1
`

type GetNotificationMessageWithUserRow struct {
	ID             pgtype.UUID        `json:"id"`
	Type           int32              `json:"type"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	ConversationID pgtype.UUID        `json:"conversation_id"`
	Content        string             `json:"content"`
	UserID         pgtype.UUID        `json:"user_id"`
	UserName       pgtype.Text        `json:"user_name"`
	UserAvatar     pgtype.Text        `json:"user_avatar"`
}

func (q *Queries) GetNotificationMessageWithUser(ctx context.Context, id pgtype.UUID) (GetNotificationMessageWithUserRow, error) {
	row := q.db.QueryRow(ctx, getNotificationMessageWithUser, id)
	var i GetNotificationMessageWithUserRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.CreatedAt,
		&i.ConversationID,
		&i.Content,
		&i.UserID,
		&i.UserName,
		&i.UserAvatar,
	)
	return i, err
}

const getParticipantByID = `-- name: GetParticipantByID :one
SELECT id, conversation_id, user_id, is_active, created_at, updated_at, deleted_at FROM participants
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetParticipantByID(ctx context.Context, id pgtype.UUID) (Participant, error) {
	row := q.db.QueryRow(ctx, getParticipantByID, id)
	var i Participant
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.UserID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getParticipantsByConversationID = `-- name: GetParticipantsByConversationID :many
SELECT u.id, u.name, u.avatar
FROM users u
JOIN participants p ON p.user_id = u.id
WHERE p.conversation_id = $1
  AND p.is_active = TRUE
  AND p.deleted_at IS NULL
  AND u.deleted_at IS NULL
LIMIT $2 OFFSET $3
`

type GetParticipantsByConversationIDParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type GetParticipantsByConversationIDRow struct {
	ID     pgtype.UUID `json:"id"`
	Name   string      `json:"name"`
	Avatar pgtype.Text `json:"avatar"`
}

func (q *Queries) GetParticipantsByConversationID(ctx context.Context, arg GetParticipantsByConversationIDParams) ([]GetParticipantsByConversationIDRow, error) {
	rows, err := q.db.Query(ctx, getParticipantsByConversationID, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetParticipantsByConversationIDRow
	for rows.Next() {
		var i GetParticipantsByConversationIDRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Avatar); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParticipantsForConversation = `-- name: GetParticipantsForConversation :many
SELECT p.id, p.conversation_id, p.user_id, p.is_active, p.created_at, p.updated_at, p.deleted_at, u.name, u.avatar
FROM participants p
JOIN users u ON u.id = p.user_id
WHERE p.conversation_id = $1 AND p.is_active = TRUE AND p.deleted_at IS NULL AND u.deleted_at IS NULL
ORDER BY p.created_at ASC
LIMIT $2 OFFSET $3
`

type GetParticipantsForConversationParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type GetParticipantsForConversationRow struct {
	ID             pgtype.UUID        `json:"id"`
	ConversationID pgtype.UUID        `json:"conversation_id"`
	UserID         pgtype.UUID        `json:"user_id"`
	IsActive       bool               `json:"is_active"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	Name           string             `json:"name"`
	Avatar         pgtype.Text        `json:"avatar"`
}

func (q *Queries) GetParticipantsForConversation(ctx context.Context, arg GetParticipantsForConversationParams) ([]GetParticipantsForConversationRow, error) {
	rows, err := q.db.Query(ctx, getParticipantsForConversation, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetParticipantsForConversationRow
	for rows.Next() {
		var i GetParticipantsForConversationRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.UserID,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Name,
			&i.Avatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParticipantsIDsByConversationID = `-- name: GetParticipantsIDsByConversationID :many
SELECT user_id
FROM participants
WHERE conversation_id = $1 AND deleted_at IS NULL
ORDER BY created_at ASC
`

func (q *Queries) GetParticipantsIDsByConversationID(ctx context.Context, conversationID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getParticipantsIDsByConversationID, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var user_id pgtype.UUID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPotentialInvitees = `-- name: GetPotentialInvitees :many
SELECT u.id, u.name, u.avatar
FROM users u
WHERE u.deleted_at IS NULL
  AND u.id NOT IN (
    SELECT user_id
    FROM participants
    WHERE conversation_id = $1
      AND is_active = TRUE
      AND deleted_at IS NULL
  )
LIMIT $2 OFFSET $3
`

type GetPotentialInviteesParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type GetPotentialInviteesRow struct {
	ID     pgtype.UUID `json:"id"`
	Name   string      `json:"name"`
	Avatar pgtype.Text `json:"avatar"`
}

func (q *Queries) GetPotentialInvitees(ctx context.Context, arg GetPotentialInviteesParams) ([]GetPotentialInviteesRow, error) {
	rows, err := q.db.Query(ctx, getPotentialInvitees, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPotentialInviteesRow
	for rows.Next() {
		var i GetPotentialInviteesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Avatar); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, avatar, name, password, refresh_token, created_at, updated_at, deleted_at FROM users
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Avatar,
		&i.Name,
		&i.Password,
		&i.RefreshToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByIDDTO = `-- name: GetUserByIDDTO :one
SELECT id, name, avatar
FROM users
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

type GetUserByIDDTORow struct {
	ID     pgtype.UUID `json:"id"`
	Name   string      `json:"name"`
	Avatar pgtype.Text `json:"avatar"`
}

func (q *Queries) GetUserByIDDTO(ctx context.Context, id pgtype.UUID) (GetUserByIDDTORow, error) {
	row := q.db.QueryRow(ctx, getUserByIDDTO, id)
	var i GetUserByIDDTORow
	err := row.Scan(&i.ID, &i.Name, &i.Avatar)
	return i, err
}

const getUserConversations = `-- name: GetUserConversations :many
WITH last_messages AS (
    SELECT conversation_id, MAX(created_at) as max_created_at
    FROM messages
    GROUP BY conversation_id
)
SELECT
    c.id as conversation_id,
    c.created_at,
    c.type,
    m.id as message_id,
    m.type as message_type,
    m.content as message_content,
    m.created_at as message_created_at,
    m.user_id as message_user_id,
    u.name as message_user_name,
    u.avatar as message_user_avatar,
    gc.avatar as group_avatar,
    gc.name as group_name,
    ou.id as other_user_id,
    ou.name as other_user_name,
    ou.avatar as other_user_avatar
FROM conversations c
JOIN participants p ON p.conversation_id = c.id
LEFT JOIN last_messages lm ON lm.conversation_id = c.id
LEFT JOIN messages m ON m.conversation_id = c.id AND m.created_at = lm.max_created_at
LEFT JOIN users u ON u.id = m.user_id
LEFT JOIN group_conversations gc ON gc.conversation_id = c.id
LEFT JOIN participants op ON op.conversation_id = c.id
    AND op.user_id <> $1
    AND op.is_active = TRUE
LEFT JOIN users ou ON ou.id = op.user_id
WHERE p.user_id = $1
  AND c.is_active = TRUE
  AND c.deleted_at IS NULL
  AND p.is_active = TRUE
  AND p.deleted_at IS NULL
ORDER BY c.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserConversationsParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetUserConversationsRow struct {
	ConversationID    pgtype.UUID        `json:"conversation_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	Type              int32              `json:"type"`
	MessageID         pgtype.UUID        `json:"message_id"`
	MessageType       pgtype.Int4        `json:"message_type"`
	MessageContent    pgtype.Text        `json:"message_content"`
	MessageCreatedAt  pgtype.Timestamptz `json:"message_created_at"`
	MessageUserID     pgtype.UUID        `json:"message_user_id"`
	MessageUserName   pgtype.Text        `json:"message_user_name"`
	MessageUserAvatar pgtype.Text        `json:"message_user_avatar"`
	GroupAvatar       pgtype.Text        `json:"group_avatar"`
	GroupName         pgtype.Text        `json:"group_name"`
	OtherUserID       pgtype.UUID        `json:"other_user_id"`
	OtherUserName     pgtype.Text        `json:"other_user_name"`
	OtherUserAvatar   pgtype.Text        `json:"other_user_avatar"`
}

func (q *Queries) GetUserConversations(ctx context.Context, arg GetUserConversationsParams) ([]GetUserConversationsRow, error) {
	rows, err := q.db.Query(ctx, getUserConversations, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserConversationsRow
	for rows.Next() {
		var i GetUserConversationsRow
		if err := rows.Scan(
			&i.ConversationID,
			&i.CreatedAt,
			&i.Type,
			&i.MessageID,
			&i.MessageType,
			&i.MessageContent,
			&i.MessageCreatedAt,
			&i.MessageUserID,
			&i.MessageUserName,
			&i.MessageUserAvatar,
			&i.GroupAvatar,
			&i.GroupName,
			&i.OtherUserID,
			&i.OtherUserName,
			&i.OtherUserAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const storeConversation = `-- name: StoreConversation :exec

INSERT INTO conversations (id, type, is_active)
VALUES ($1, $2, $3)
`

type StoreConversationParams struct {
	ID       pgtype.UUID `json:"id"`
	Type     int32       `json:"type"`
	IsActive bool        `json:"is_active"`
}

// Conversation queries
func (q *Queries) StoreConversation(ctx context.Context, arg StoreConversationParams) error {
	_, err := q.db.Exec(ctx, storeConversation, arg.ID, arg.Type, arg.IsActive)
	return err
}

const storeGroupConversation = `-- name: StoreGroupConversation :exec

INSERT INTO group_conversations (id, name, avatar, conversation_id, owner_id)
VALUES ($1, $2, $3, $4, $5)
`

type StoreGroupConversationParams struct {
	ID             pgtype.UUID `json:"id"`
	Name           string      `json:"name"`
	Avatar         pgtype.Text `json:"avatar"`
	ConversationID pgtype.UUID `json:"conversation_id"`
	OwnerID        pgtype.UUID `json:"owner_id"`
}

// GroupConversation queries
func (q *Queries) StoreGroupConversation(ctx context.Context, arg StoreGroupConversationParams) error {
	_, err := q.db.Exec(ctx, storeGroupConversation,
		arg.ID,
		arg.Name,
		arg.Avatar,
		arg.ConversationID,
		arg.OwnerID,
	)
	return err
}

const storeMessage = `-- name: StoreMessage :exec

INSERT INTO messages (id, conversation_id, user_id, content, type)
VALUES ($1, $2, $3, $4, $5)
`

type StoreMessageParams struct {
	ID             pgtype.UUID `json:"id"`
	ConversationID pgtype.UUID `json:"conversation_id"`
	UserID         pgtype.UUID `json:"user_id"`
	Content        string      `json:"content"`
	Type           int32       `json:"type"`
}

// Message queries
func (q *Queries) StoreMessage(ctx context.Context, arg StoreMessageParams) error {
	_, err := q.db.Exec(ctx, storeMessage,
		arg.ID,
		arg.ConversationID,
		arg.UserID,
		arg.Content,
		arg.Type,
	)
	return err
}

const storeParticipant = `-- name: StoreParticipant :exec

INSERT INTO participants (id, conversation_id, user_id, is_active)
VALUES ($1, $2, $3, $4)
`

type StoreParticipantParams struct {
	ID             pgtype.UUID `json:"id"`
	ConversationID pgtype.UUID `json:"conversation_id"`
	UserID         pgtype.UUID `json:"user_id"`
	IsActive       bool        `json:"is_active"`
}

// Participant queries
func (q *Queries) StoreParticipant(ctx context.Context, arg StoreParticipantParams) error {
	_, err := q.db.Exec(ctx, storeParticipant,
		arg.ID,
		arg.ConversationID,
		arg.UserID,
		arg.IsActive,
	)
	return err
}

const storeUser = `-- name: StoreUser :exec

INSERT INTO users (id, avatar, name, password, refresh_token)
VALUES ($1, $2, $3, $4, $5)
`

type StoreUserParams struct {
	ID           pgtype.UUID `json:"id"`
	Avatar       pgtype.Text `json:"avatar"`
	Name         string      `json:"name"`
	Password     string      `json:"password"`
	RefreshToken pgtype.Text `json:"refresh_token"`
}

// User queries
func (q *Queries) StoreUser(ctx context.Context, arg StoreUserParams) error {
	_, err := q.db.Exec(ctx, storeUser,
		arg.ID,
		arg.Avatar,
		arg.Name,
		arg.Password,
		arg.RefreshToken,
	)
	return err
}

const updateConversation = `-- name: UpdateConversation :exec
UPDATE conversations
SET type = $2, is_active = $3, updated_at = NOW()
WHERE id = $1
`

type UpdateConversationParams struct {
	ID       pgtype.UUID `json:"id"`
	Type     int32       `json:"type"`
	IsActive bool        `json:"is_active"`
}

func (q *Queries) UpdateConversation(ctx context.Context, arg UpdateConversationParams) error {
	_, err := q.db.Exec(ctx, updateConversation, arg.ID, arg.Type, arg.IsActive)
	return err
}

const updateGroupConversation = `-- name: UpdateGroupConversation :exec
UPDATE group_conversations
SET name = $2, avatar = $3, updated_at = NOW()
WHERE conversation_id = $1
`

type UpdateGroupConversationParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	Name           string      `json:"name"`
	Avatar         pgtype.Text `json:"avatar"`
}

func (q *Queries) UpdateGroupConversation(ctx context.Context, arg UpdateGroupConversationParams) error {
	_, err := q.db.Exec(ctx, updateGroupConversation, arg.ConversationID, arg.Name, arg.Avatar)
	return err
}

const updateParticipant = `-- name: UpdateParticipant :exec
UPDATE participants
SET is_active = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateParticipantParams struct {
	ID       pgtype.UUID `json:"id"`
	IsActive bool        `json:"is_active"`
}

func (q *Queries) UpdateParticipant(ctx context.Context, arg UpdateParticipantParams) error {
	_, err := q.db.Exec(ctx, updateParticipant, arg.ID, arg.IsActive)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET avatar = $2, name = $3, password = $4, refresh_token = $5, updated_at = NOW()
WHERE id = $1
`

type UpdateUserParams struct {
	ID           pgtype.UUID `json:"id"`
	Avatar       pgtype.Text `json:"avatar"`
	Name         string      `json:"name"`
	Password     string      `json:"password"`
	RefreshToken pgtype.Text `json:"refresh_token"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.Avatar,
		arg.Name,
		arg.Password,
		arg.RefreshToken,
	)
	return err
}

const updateUserRefreshToken = `-- name: UpdateUserRefreshToken :exec
UPDATE users
SET refresh_token = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateUserRefreshTokenParams struct {
	ID           pgtype.UUID `json:"id"`
	RefreshToken pgtype.Text `json:"refresh_token"`
}

func (q *Queries) UpdateUserRefreshToken(ctx context.Context, arg UpdateUserRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, updateUserRefreshToken, arg.ID, arg.RefreshToken)
	return err
}
