// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteConversation = `-- name: DeleteConversation :exec
UPDATE conversations
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteConversation(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteConversation, id)
	return err
}

const deleteParticipant = `-- name: DeleteParticipant :exec
UPDATE participants
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteParticipant(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteParticipant, id)
	return err
}

const findParticipantByConversationAndUser = `-- name: FindParticipantByConversationAndUser :one
SELECT id, conversation_id, user_id, created_at, updated_at, deleted_at FROM participants
WHERE conversation_id = $1 AND user_id = $2 AND deleted_at IS NULL
LIMIT 1
`

type FindParticipantByConversationAndUserParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	UserID         pgtype.UUID `json:"user_id"`
}

func (q *Queries) FindParticipantByConversationAndUser(ctx context.Context, arg FindParticipantByConversationAndUserParams) (Participant, error) {
	row := q.db.QueryRow(ctx, findParticipantByConversationAndUser, arg.ConversationID, arg.UserID)
	var i Participant
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const findUserByUsername = `-- name: FindUserByUsername :one
SELECT id, avatar, name, password, refresh_token, created_at, updated_at, deleted_at FROM users
WHERE name = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) FindUserByUsername(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByUsername, name)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Avatar,
		&i.Name,
		&i.Password,
		&i.RefreshToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getContacts = `-- name: GetContacts :many

SELECT id, name, avatar
FROM users
WHERE deleted_at IS NULL AND id != $1
LIMIT $2 OFFSET $3
`

type GetContactsParams struct {
	ID     pgtype.UUID `json:"id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetContactsRow struct {
	ID     pgtype.UUID `json:"id"`
	Name   string      `json:"name"`
	Avatar pgtype.Text `json:"avatar"`
}

// Complex queries for read model
func (q *Queries) GetContacts(ctx context.Context, arg GetContactsParams) ([]GetContactsRow, error) {
	rows, err := q.db.Query(ctx, getContacts, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContactsRow
	for rows.Next() {
		var i GetContactsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Avatar); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationFull = `-- name: GetConversationFull :one
WITH participants_count AS (
    SELECT COUNT(*) as count
    FROM participants
    WHERE conversation_id = $1
      AND deleted_at IS NULL
)
SELECT
    c.id as conversation_id,
    c.created_at,
    c.type,
    ou.id as other_user_id,
    ou.name as other_user_name,
    ou.avatar as other_user_avatar,
    gc.avatar as group_avatar,
    gc.name as group_name,
    gc.owner_id as group_owner_id,
    pc.count as participants_count,
    up.id as user_participant_id
FROM conversations c
LEFT JOIN participants op ON op.conversation_id = c.id
    AND op.user_id <> $2
LEFT JOIN users ou ON ou.id = op.user_id
LEFT JOIN group_conversations gc ON gc.conversation_id = c.id
LEFT JOIN participants pc_sub ON pc_sub.conversation_id = c.id AND pc_sub.user_id = $2
LEFT JOIN participants up ON up.conversation_id = c.id AND up.user_id = $2
CROSS JOIN participants_count pc
WHERE c.id = $1 AND c.deleted_at IS NULL
LIMIT 1
`

type GetConversationFullParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetConversationFullRow struct {
	ConversationID    pgtype.UUID        `json:"conversation_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	Type              int32              `json:"type"`
	OtherUserID       pgtype.UUID        `json:"other_user_id"`
	OtherUserName     pgtype.Text        `json:"other_user_name"`
	OtherUserAvatar   pgtype.Text        `json:"other_user_avatar"`
	GroupAvatar       pgtype.Text        `json:"group_avatar"`
	GroupName         pgtype.Text        `json:"group_name"`
	GroupOwnerID      pgtype.UUID        `json:"group_owner_id"`
	ParticipantsCount int64              `json:"participants_count"`
	UserParticipantID pgtype.UUID        `json:"user_participant_id"`
}

func (q *Queries) GetConversationFull(ctx context.Context, arg GetConversationFullParams) (GetConversationFullRow, error) {
	row := q.db.QueryRow(ctx, getConversationFull, arg.ID, arg.UserID)
	var i GetConversationFullRow
	err := row.Scan(
		&i.ConversationID,
		&i.CreatedAt,
		&i.Type,
		&i.OtherUserID,
		&i.OtherUserName,
		&i.OtherUserAvatar,
		&i.GroupAvatar,
		&i.GroupName,
		&i.GroupOwnerID,
		&i.ParticipantsCount,
		&i.UserParticipantID,
	)
	return i, err
}

const getConversationIDsByUserID = `-- name: GetConversationIDsByUserID :many
SELECT conversation_id
FROM participants
WHERE user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetConversationIDsByUserID(ctx context.Context, userID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getConversationIDsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var conversation_id pgtype.UUID
		if err := rows.Scan(&conversation_id); err != nil {
			return nil, err
		}
		items = append(items, conversation_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationMessagesRaw = `-- name: GetConversationMessagesRaw :many
SELECT
    m.id,
    m.type,
    m.created_at,
    m.conversation_id,
    m.content,
    u.id as user_id,
    u.name as user_name,
    u.avatar as user_avatar
FROM messages m
LEFT JOIN users u ON u.id = m.user_id
WHERE m.conversation_id = $1 AND m.deleted_at IS NULL
ORDER BY m.created_at ASC
LIMIT $2 OFFSET $3
`

type GetConversationMessagesRawParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type GetConversationMessagesRawRow struct {
	ID             pgtype.UUID        `json:"id"`
	Type           int32              `json:"type"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	ConversationID pgtype.UUID        `json:"conversation_id"`
	Content        string             `json:"content"`
	UserID         pgtype.UUID        `json:"user_id"`
	UserName       pgtype.Text        `json:"user_name"`
	UserAvatar     pgtype.Text        `json:"user_avatar"`
}

func (q *Queries) GetConversationMessagesRaw(ctx context.Context, arg GetConversationMessagesRawParams) ([]GetConversationMessagesRawRow, error) {
	rows, err := q.db.Query(ctx, getConversationMessagesRaw, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversationMessagesRawRow
	for rows.Next() {
		var i GetConversationMessagesRawRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.CreatedAt,
			&i.ConversationID,
			&i.Content,
			&i.UserID,
			&i.UserName,
			&i.UserAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDirectConversationBetweenUsers = `-- name: GetDirectConversationBetweenUsers :one
SELECT c.id, c.type, c.created_at, c.updated_at, c.deleted_at
FROM conversations c
JOIN participants p1 ON p1.conversation_id = c.id AND p1.user_id = $1
JOIN participants p2 ON p2.conversation_id = c.id AND p2.user_id = $2
WHERE c.type = 1
  AND c.deleted_at IS NULL
  AND p1.deleted_at IS NULL
  AND p2.deleted_at IS NULL
LIMIT 1
`

type GetDirectConversationBetweenUsersParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	UserID_2 pgtype.UUID `json:"user_id_2"`
}

func (q *Queries) GetDirectConversationBetweenUsers(ctx context.Context, arg GetDirectConversationBetweenUsersParams) (Conversation, error) {
	row := q.db.QueryRow(ctx, getDirectConversationBetweenUsers, arg.UserID, arg.UserID_2)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getDirectConversationWithParticipants = `-- name: GetDirectConversationWithParticipants :one
SELECT c.id, c.type, c.created_at, c.updated_at,
       ARRAY_AGG(p.user_id) as participant_user_ids
FROM conversations c
JOIN participants p ON p.conversation_id = c.id
WHERE c.id = $1 AND c.deleted_at IS NULL AND p.deleted_at IS NULL
GROUP BY c.id
`

type GetDirectConversationWithParticipantsRow struct {
	ID                 pgtype.UUID        `json:"id"`
	Type               int32              `json:"type"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ParticipantUserIds interface{}        `json:"participant_user_ids"`
}

func (q *Queries) GetDirectConversationWithParticipants(ctx context.Context, id pgtype.UUID) (GetDirectConversationWithParticipantsRow, error) {
	row := q.db.QueryRow(ctx, getDirectConversationWithParticipants, id)
	var i GetDirectConversationWithParticipantsRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ParticipantUserIds,
	)
	return i, err
}

const getGroupConversationWithOwner = `-- name: GetGroupConversationWithOwner :one
SELECT
    gc.id,
    gc.name,
    gc.avatar,
    gc.conversation_id,
    gc.owner_id,
    c.type as conversation_type,
    p.id as owner_participant_id,
    p.user_id as owner_user_id,
    p.conversation_id as owner_conversation_id
FROM group_conversations gc
JOIN conversations c ON c.id = gc.conversation_id
JOIN participants p ON p.conversation_id = gc.conversation_id AND p.user_id = gc.owner_id
WHERE gc.conversation_id = $1
  AND gc.deleted_at IS NULL
  AND c.deleted_at IS NULL
  AND p.deleted_at IS NULL
LIMIT 1
`

type GetGroupConversationWithOwnerRow struct {
	ID                  pgtype.UUID `json:"id"`
	Name                string      `json:"name"`
	Avatar              pgtype.Text `json:"avatar"`
	ConversationID      pgtype.UUID `json:"conversation_id"`
	OwnerID             pgtype.UUID `json:"owner_id"`
	ConversationType    int32       `json:"conversation_type"`
	OwnerParticipantID  pgtype.UUID `json:"owner_participant_id"`
	OwnerUserID         pgtype.UUID `json:"owner_user_id"`
	OwnerConversationID pgtype.UUID `json:"owner_conversation_id"`
}

func (q *Queries) GetGroupConversationWithOwner(ctx context.Context, conversationID pgtype.UUID) (GetGroupConversationWithOwnerRow, error) {
	row := q.db.QueryRow(ctx, getGroupConversationWithOwner, conversationID)
	var i GetGroupConversationWithOwnerRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Avatar,
		&i.ConversationID,
		&i.OwnerID,
		&i.ConversationType,
		&i.OwnerParticipantID,
		&i.OwnerUserID,
		&i.OwnerConversationID,
	)
	return i, err
}

const getMessageWithUser = `-- name: GetMessageWithUser :one
SELECT
    m.id, m.type, m.created_at, m.conversation_id, m.content,
    u.id as user_id, u.name as user_name, u.avatar as user_avatar
FROM messages m
JOIN users u ON u.id = m.user_id
WHERE m.id = $1 AND u.deleted_at IS NULL
LIMIT 1
`

type GetMessageWithUserRow struct {
	ID             pgtype.UUID        `json:"id"`
	Type           int32              `json:"type"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	ConversationID pgtype.UUID        `json:"conversation_id"`
	Content        string             `json:"content"`
	UserID         pgtype.UUID        `json:"user_id"`
	UserName       string             `json:"user_name"`
	UserAvatar     pgtype.Text        `json:"user_avatar"`
}

func (q *Queries) GetMessageWithUser(ctx context.Context, id pgtype.UUID) (GetMessageWithUserRow, error) {
	row := q.db.QueryRow(ctx, getMessageWithUser, id)
	var i GetMessageWithUserRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.CreatedAt,
		&i.ConversationID,
		&i.Content,
		&i.UserID,
		&i.UserName,
		&i.UserAvatar,
	)
	return i, err
}

const getNotificationMessageRaw = `-- name: GetNotificationMessageRaw :one
SELECT
    m.id,
    m.type,
    m.created_at,
    m.conversation_id,
    m.content,
    u.id as user_id,
    u.name as user_name,
    u.avatar as user_avatar
FROM messages m
LEFT JOIN users u ON u.id = m.user_id
WHERE m.id = $1 AND m.deleted_at IS NULL
LIMIT 1
`

type GetNotificationMessageRawRow struct {
	ID             pgtype.UUID        `json:"id"`
	Type           int32              `json:"type"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	ConversationID pgtype.UUID        `json:"conversation_id"`
	Content        string             `json:"content"`
	UserID         pgtype.UUID        `json:"user_id"`
	UserName       pgtype.Text        `json:"user_name"`
	UserAvatar     pgtype.Text        `json:"user_avatar"`
}

func (q *Queries) GetNotificationMessageRaw(ctx context.Context, id pgtype.UUID) (GetNotificationMessageRawRow, error) {
	row := q.db.QueryRow(ctx, getNotificationMessageRaw, id)
	var i GetNotificationMessageRawRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.CreatedAt,
		&i.ConversationID,
		&i.Content,
		&i.UserID,
		&i.UserName,
		&i.UserAvatar,
	)
	return i, err
}

const getParticipantsByConversationID = `-- name: GetParticipantsByConversationID :many
SELECT u.id, u.name, u.avatar
FROM users u
JOIN participants p ON p.user_id = u.id
WHERE p.conversation_id = $1
  AND p.deleted_at IS NULL
  AND u.deleted_at IS NULL
LIMIT $2 OFFSET $3
`

type GetParticipantsByConversationIDParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type GetParticipantsByConversationIDRow struct {
	ID     pgtype.UUID `json:"id"`
	Name   string      `json:"name"`
	Avatar pgtype.Text `json:"avatar"`
}

func (q *Queries) GetParticipantsByConversationID(ctx context.Context, arg GetParticipantsByConversationIDParams) ([]GetParticipantsByConversationIDRow, error) {
	rows, err := q.db.Query(ctx, getParticipantsByConversationID, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetParticipantsByConversationIDRow
	for rows.Next() {
		var i GetParticipantsByConversationIDRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Avatar); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParticipantsIDsByConversationID = `-- name: GetParticipantsIDsByConversationID :many
SELECT user_id
FROM participants
WHERE conversation_id = $1 AND deleted_at IS NULL
ORDER BY created_at ASC
`

func (q *Queries) GetParticipantsIDsByConversationID(ctx context.Context, conversationID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getParticipantsIDsByConversationID, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var user_id pgtype.UUID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPotentialInvitees = `-- name: GetPotentialInvitees :many
SELECT u.id, u.name, u.avatar
FROM users u
WHERE u.deleted_at IS NULL
  AND u.id NOT IN (
    SELECT user_id
    FROM participants
    WHERE conversation_id = $1
      AND deleted_at IS NULL
  )
LIMIT $2 OFFSET $3
`

type GetPotentialInviteesParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type GetPotentialInviteesRow struct {
	ID     pgtype.UUID `json:"id"`
	Name   string      `json:"name"`
	Avatar pgtype.Text `json:"avatar"`
}

func (q *Queries) GetPotentialInvitees(ctx context.Context, arg GetPotentialInviteesParams) ([]GetPotentialInviteesRow, error) {
	rows, err := q.db.Query(ctx, getPotentialInvitees, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPotentialInviteesRow
	for rows.Next() {
		var i GetPotentialInviteesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Avatar); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, avatar, name, password, refresh_token, created_at, updated_at, deleted_at FROM users
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Avatar,
		&i.Name,
		&i.Password,
		&i.RefreshToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByIDDTO = `-- name: GetUserByIDDTO :one
SELECT id, name, avatar
FROM users
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

type GetUserByIDDTORow struct {
	ID     pgtype.UUID `json:"id"`
	Name   string      `json:"name"`
	Avatar pgtype.Text `json:"avatar"`
}

func (q *Queries) GetUserByIDDTO(ctx context.Context, id pgtype.UUID) (GetUserByIDDTORow, error) {
	row := q.db.QueryRow(ctx, getUserByIDDTO, id)
	var i GetUserByIDDTORow
	err := row.Scan(&i.ID, &i.Name, &i.Avatar)
	return i, err
}

const getUserConversations = `-- name: GetUserConversations :many
WITH last_messages AS (
    SELECT conversation_id, MAX(created_at) as max_created_at
    FROM messages
    GROUP BY conversation_id
)
SELECT
    c.id as conversation_id,
    c.created_at,
    c.type,
    m.id as message_id,
    m.type as message_type,
    m.content as message_content,
    m.created_at as message_created_at,
    m.user_id as message_user_id,
    u.name as message_user_name,
    u.avatar as message_user_avatar,
    gc.avatar as group_avatar,
    gc.name as group_name,
    ou.id as other_user_id,
    ou.name as other_user_name,
    ou.avatar as other_user_avatar
FROM conversations c
JOIN participants p ON p.conversation_id = c.id
LEFT JOIN last_messages lm ON lm.conversation_id = c.id
LEFT JOIN messages m ON m.conversation_id = c.id AND m.created_at = lm.max_created_at
LEFT JOIN users u ON u.id = m.user_id
LEFT JOIN group_conversations gc ON gc.conversation_id = c.id
LEFT JOIN participants op ON op.conversation_id = c.id
    AND op.user_id <> $1
LEFT JOIN users ou ON ou.id = op.user_id
WHERE p.user_id = $1
  AND c.deleted_at IS NULL
  AND p.deleted_at IS NULL
ORDER BY c.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserConversationsParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetUserConversationsRow struct {
	ConversationID    pgtype.UUID        `json:"conversation_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	Type              int32              `json:"type"`
	MessageID         pgtype.UUID        `json:"message_id"`
	MessageType       pgtype.Int4        `json:"message_type"`
	MessageContent    pgtype.Text        `json:"message_content"`
	MessageCreatedAt  pgtype.Timestamptz `json:"message_created_at"`
	MessageUserID     pgtype.UUID        `json:"message_user_id"`
	MessageUserName   pgtype.Text        `json:"message_user_name"`
	MessageUserAvatar pgtype.Text        `json:"message_user_avatar"`
	GroupAvatar       pgtype.Text        `json:"group_avatar"`
	GroupName         pgtype.Text        `json:"group_name"`
	OtherUserID       pgtype.UUID        `json:"other_user_id"`
	OtherUserName     pgtype.Text        `json:"other_user_name"`
	OtherUserAvatar   pgtype.Text        `json:"other_user_avatar"`
}

func (q *Queries) GetUserConversations(ctx context.Context, arg GetUserConversationsParams) ([]GetUserConversationsRow, error) {
	rows, err := q.db.Query(ctx, getUserConversations, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserConversationsRow
	for rows.Next() {
		var i GetUserConversationsRow
		if err := rows.Scan(
			&i.ConversationID,
			&i.CreatedAt,
			&i.Type,
			&i.MessageID,
			&i.MessageType,
			&i.MessageContent,
			&i.MessageCreatedAt,
			&i.MessageUserID,
			&i.MessageUserName,
			&i.MessageUserAvatar,
			&i.GroupAvatar,
			&i.GroupName,
			&i.OtherUserID,
			&i.OtherUserName,
			&i.OtherUserAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const inviteToConversationAtomic = `-- name: InviteToConversationAtomic :one
WITH valid_conversation AS (
    SELECT gc.conversation_id as conv_id
    FROM group_conversations gc
    JOIN conversations c ON c.id = gc.conversation_id
    WHERE gc.conversation_id = $1 
        AND c.deleted_at IS NULL
        AND gc.deleted_at IS NULL
),
valid_invitee AS (
    SELECT u.id as user_id FROM users u WHERE u.id = $2 AND u.deleted_at IS NULL
),
new_participant AS (
    INSERT INTO participants (id, conversation_id, user_id, created_at)
    SELECT $3, vc.conv_id, vi.user_id, NOW()
    FROM valid_conversation vc, valid_invitee vi
    ON CONFLICT DO NOTHING
    RETURNING user_id
)
SELECT user_id FROM new_participant
`

type InviteToConversationAtomicParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	ID             pgtype.UUID `json:"id"`
	ID_2           pgtype.UUID `json:"id_2"`
}

func (q *Queries) InviteToConversationAtomic(ctx context.Context, arg InviteToConversationAtomicParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, inviteToConversationAtomic, arg.ConversationID, arg.ID, arg.ID_2)
	var user_id pgtype.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const isMember = `-- name: IsMember :one
SELECT EXISTS(
    SELECT 1 FROM participants
    WHERE conversation_id = $1 AND user_id = $2 AND deleted_at IS NULL
)
`

type IsMemberParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	UserID         pgtype.UUID `json:"user_id"`
}

func (q *Queries) IsMember(ctx context.Context, arg IsMemberParams) (bool, error) {
	row := q.db.QueryRow(ctx, isMember, arg.ConversationID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isMemberOwner = `-- name: IsMemberOwner :one
SELECT EXISTS(
    SELECT 1 FROM group_conversations gc
    JOIN conversations c ON c.id = gc.conversation_id
    JOIN participants p ON p.conversation_id = gc.conversation_id AND p.user_id = $2
    WHERE gc.conversation_id = $1 AND gc.owner_id = $2
      AND gc.deleted_at IS NULL AND c.deleted_at IS NULL AND p.deleted_at IS NULL
)
`

type IsMemberOwnerParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	UserID         pgtype.UUID `json:"user_id"`
}

func (q *Queries) IsMemberOwner(ctx context.Context, arg IsMemberOwnerParams) (bool, error) {
	row := q.db.QueryRow(ctx, isMemberOwner, arg.ConversationID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const leaveConversationAtomic = `-- name: LeaveConversationAtomic :execrows
UPDATE participants
SET deleted_at = NOW(), updated_at = NOW()
WHERE conversation_id = $1
  AND user_id = $2
  AND deleted_at IS NULL
`

type LeaveConversationAtomicParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	UserID         pgtype.UUID `json:"user_id"`
}

func (q *Queries) LeaveConversationAtomic(ctx context.Context, arg LeaveConversationAtomicParams) (int64, error) {
	result, err := q.db.Exec(ctx, leaveConversationAtomic, arg.ConversationID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const renameConversationAndReturn = `-- name: RenameConversationAndReturn :execrows
UPDATE group_conversations
SET name = $2, updated_at = NOW()
WHERE conversation_id = $1
  AND deleted_at IS NULL
  AND EXISTS (
    SELECT 1 FROM conversations c WHERE c.id = conversation_id AND c.deleted_at IS NULL
  )
`

type RenameConversationAndReturnParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	Name           string      `json:"name"`
}

func (q *Queries) RenameConversationAndReturn(ctx context.Context, arg RenameConversationAndReturnParams) (int64, error) {
	result, err := q.db.Exec(ctx, renameConversationAndReturn, arg.ConversationID, arg.Name)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const renameGroupConversation = `-- name: RenameGroupConversation :exec
UPDATE group_conversations
SET name = $2, updated_at = NOW()
WHERE conversation_id = $1
`

type RenameGroupConversationParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	Name           string      `json:"name"`
}

func (q *Queries) RenameGroupConversation(ctx context.Context, arg RenameGroupConversationParams) error {
	_, err := q.db.Exec(ctx, renameGroupConversation, arg.ConversationID, arg.Name)
	return err
}

const storeConversation = `-- name: StoreConversation :exec

INSERT INTO conversations (id, type)
VALUES ($1, $2)
`

type StoreConversationParams struct {
	ID   pgtype.UUID `json:"id"`
	Type int32       `json:"type"`
}

// Conversation queries
func (q *Queries) StoreConversation(ctx context.Context, arg StoreConversationParams) error {
	_, err := q.db.Exec(ctx, storeConversation, arg.ID, arg.Type)
	return err
}

const storeGroupConversation = `-- name: StoreGroupConversation :exec

INSERT INTO group_conversations (id, name, avatar, conversation_id, owner_id)
VALUES ($1, $2, $3, $4, $5)
`

type StoreGroupConversationParams struct {
	ID             pgtype.UUID `json:"id"`
	Name           string      `json:"name"`
	Avatar         pgtype.Text `json:"avatar"`
	ConversationID pgtype.UUID `json:"conversation_id"`
	OwnerID        pgtype.UUID `json:"owner_id"`
}

// GroupConversation queries
func (q *Queries) StoreGroupConversation(ctx context.Context, arg StoreGroupConversationParams) error {
	_, err := q.db.Exec(ctx, storeGroupConversation,
		arg.ID,
		arg.Name,
		arg.Avatar,
		arg.ConversationID,
		arg.OwnerID,
	)
	return err
}

const storeMessage = `-- name: StoreMessage :exec

INSERT INTO messages (id, conversation_id, user_id, content, type, created_at)
VALUES ($1, $2, $3, $4, $5, NOW())
`

type StoreMessageParams struct {
	ID             pgtype.UUID `json:"id"`
	ConversationID pgtype.UUID `json:"conversation_id"`
	UserID         pgtype.UUID `json:"user_id"`
	Content        string      `json:"content"`
	Type           int32       `json:"type"`
}

// Message queries
func (q *Queries) StoreMessage(ctx context.Context, arg StoreMessageParams) error {
	_, err := q.db.Exec(ctx, storeMessage,
		arg.ID,
		arg.ConversationID,
		arg.UserID,
		arg.Content,
		arg.Type,
	)
	return err
}

const storeMessageAndReturn = `-- name: StoreMessageAndReturn :one
WITH new_message AS (
    INSERT INTO messages (id, conversation_id, user_id, content, type, created_at)
    VALUES ($1, $2, $3, $4, $5, NOW())
    RETURNING id, type, created_at, conversation_id, content
)
SELECT
    nm.id, nm.type, nm.created_at, nm.conversation_id,
    nm.content as formatted_text,
    u.id as user_id, u.name as user_name, u.avatar as user_avatar
FROM new_message nm
JOIN users u ON u.id = nm.user_id
WHERE u.deleted_at IS NULL
`

type StoreMessageAndReturnParams struct {
	ID             pgtype.UUID `json:"id"`
	ConversationID pgtype.UUID `json:"conversation_id"`
	UserID         pgtype.UUID `json:"user_id"`
	Content        string      `json:"content"`
	Type           int32       `json:"type"`
}

type StoreMessageAndReturnRow struct {
	ID             pgtype.UUID        `json:"id"`
	Type           int32              `json:"type"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	ConversationID pgtype.UUID        `json:"conversation_id"`
	FormattedText  string             `json:"formatted_text"`
	UserID         pgtype.UUID        `json:"user_id"`
	UserName       string             `json:"user_name"`
	UserAvatar     pgtype.Text        `json:"user_avatar"`
}

func (q *Queries) StoreMessageAndReturn(ctx context.Context, arg StoreMessageAndReturnParams) (StoreMessageAndReturnRow, error) {
	row := q.db.QueryRow(ctx, storeMessageAndReturn,
		arg.ID,
		arg.ConversationID,
		arg.UserID,
		arg.Content,
		arg.Type,
	)
	var i StoreMessageAndReturnRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.CreatedAt,
		&i.ConversationID,
		&i.FormattedText,
		&i.UserID,
		&i.UserName,
		&i.UserAvatar,
	)
	return i, err
}

const storeParticipant = `-- name: StoreParticipant :exec

INSERT INTO participants (id, conversation_id, user_id)
VALUES ($1, $2, $3)
`

type StoreParticipantParams struct {
	ID             pgtype.UUID `json:"id"`
	ConversationID pgtype.UUID `json:"conversation_id"`
	UserID         pgtype.UUID `json:"user_id"`
}

// Participant queries
func (q *Queries) StoreParticipant(ctx context.Context, arg StoreParticipantParams) error {
	_, err := q.db.Exec(ctx, storeParticipant, arg.ID, arg.ConversationID, arg.UserID)
	return err
}

const storeParticipantsBatch = `-- name: StoreParticipantsBatch :exec
INSERT INTO participants (id, conversation_id, user_id, created_at)
SELECT unnest($1::uuid[]), $2, unnest($3::uuid[]), NOW()
`

type StoreParticipantsBatchParams struct {
	Column1        []pgtype.UUID `json:"column_1"`
	ConversationID pgtype.UUID   `json:"conversation_id"`
	Column3        []pgtype.UUID `json:"column_3"`
}

func (q *Queries) StoreParticipantsBatch(ctx context.Context, arg StoreParticipantsBatchParams) error {
	_, err := q.db.Exec(ctx, storeParticipantsBatch, arg.Column1, arg.ConversationID, arg.Column3)
	return err
}

const storeUser = `-- name: StoreUser :exec

INSERT INTO users (id, avatar, name, password, refresh_token)
VALUES ($1, $2, $3, $4, $5)
`

type StoreUserParams struct {
	ID           pgtype.UUID `json:"id"`
	Avatar       pgtype.Text `json:"avatar"`
	Name         string      `json:"name"`
	Password     string      `json:"password"`
	RefreshToken pgtype.Text `json:"refresh_token"`
}

// User queries
func (q *Queries) StoreUser(ctx context.Context, arg StoreUserParams) error {
	_, err := q.db.Exec(ctx, storeUser,
		arg.ID,
		arg.Avatar,
		arg.Name,
		arg.Password,
		arg.RefreshToken,
	)
	return err
}

const updateConversation = `-- name: UpdateConversation :exec
UPDATE conversations
SET type = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateConversationParams struct {
	ID   pgtype.UUID `json:"id"`
	Type int32       `json:"type"`
}

func (q *Queries) UpdateConversation(ctx context.Context, arg UpdateConversationParams) error {
	_, err := q.db.Exec(ctx, updateConversation, arg.ID, arg.Type)
	return err
}

const updateGroupConversation = `-- name: UpdateGroupConversation :exec
UPDATE group_conversations
SET name = $2, avatar = $3, updated_at = NOW()
WHERE conversation_id = $1
`

type UpdateGroupConversationParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	Name           string      `json:"name"`
	Avatar         pgtype.Text `json:"avatar"`
}

func (q *Queries) UpdateGroupConversation(ctx context.Context, arg UpdateGroupConversationParams) error {
	_, err := q.db.Exec(ctx, updateGroupConversation, arg.ConversationID, arg.Name, arg.Avatar)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET avatar = $2, name = $3, password = $4, refresh_token = $5, updated_at = NOW()
WHERE id = $1
`

type UpdateUserParams struct {
	ID           pgtype.UUID `json:"id"`
	Avatar       pgtype.Text `json:"avatar"`
	Name         string      `json:"name"`
	Password     string      `json:"password"`
	RefreshToken pgtype.Text `json:"refresh_token"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.Avatar,
		arg.Name,
		arg.Password,
		arg.RefreshToken,
	)
	return err
}

const updateUserRefreshToken = `-- name: UpdateUserRefreshToken :exec
UPDATE users
SET refresh_token = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateUserRefreshTokenParams struct {
	ID           pgtype.UUID `json:"id"`
	RefreshToken pgtype.Text `json:"refresh_token"`
}

func (q *Queries) UpdateUserRefreshToken(ctx context.Context, arg UpdateUserRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, updateUserRefreshToken, arg.ID, arg.RefreshToken)
	return err
}
